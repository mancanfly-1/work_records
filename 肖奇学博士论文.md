# 面向 Linux C 程序漏洞挖掘的动态符号执行优化技术研究

## backgroud

### 问题背景
很多系统都会大量的引入第三方库，如libc、media framework 等需要用于与操作系统进行交互。所以这些库是非常重要的。有很多根据这些库中漏洞来对系统进行攻击。
这些库有以下相关特征：
- 安全漏洞有着重要的影响。这些软件或动态库被大量的软件和系统使用，一旦发现它们的安全漏洞，可以直接影响到所有依赖他们的软件和系统。
- 为了达到较好的运行性能，这些第三方软件和动态库通常都采用 c/c++ 开发。
- 代码规模适中，相比操作系统、浏览器等大型系统软件要简单，相比简单的示例代码又具有一定的复杂性。
- 被广泛使用并经过了大量测试，简单浅层的漏洞都已被修复，潜在的安全漏洞难以被发现。
### 相关技术
软件漏洞挖掘的方法大概分为静态分析、动态分析以及动静结合分析三个部分
- 静态分析
词法分析、数据流分析、符号化分析、模型检测、定理证明
- 动态分析
事件空间遍历测试、输入空间遍历测试、程序执行路径遍历测试
- 动静结合分析
    - 一类是以动态分析(如 Fuzzing 测试)作为漏洞发现的主要手段，以静态分析为辅助方法。这种方法典型的工具包 括 AFL、SAGE、Driller等。
    - 另一类是以程序分析(约束求解或 模式匹配)作为漏洞发现的手段，通过动态执行来收集更多用于分析信息，或者辅助程序分析绕过相应的阻碍(如指针、外部函数调用等)。典型的工具包括 KLEE、Mayhem等，其中 KLEE 主要 针对有源码的程序，而 Mayhem 可以直接对二进制程序进行分析。
在这些动静结合的漏洞挖掘方法中，大部分都使用了符号执行和具体执行相结合的方法。这种方法也叫动态符号执行，相应工具包括KLEE、SAGE、Mayhem、S2E、SymDrive、KATCH、Veritesting、 Hercules、Driller、Hunter等。
- 动态符号执行
    动态符号执行技术是动静结合分析的一种，包括Concolic测试和执行生成测试。Concolic测试以具体执行为主，而符号执行辅助具体执行；而执行生成测试以符号执行为主，而具体执行帮助符号执行进行高效、深入的执行。
### 本文侧重
针对于Linux中的基础工具和动态库程序，关注实现层面的安全漏洞（缓冲区溢出、整数溢出、内存越界读写）。这种漏洞的触发需要满足两个条件，1，在代码层运行到漏洞所在的路径；2，数据层面还能满足漏洞触发。
本文采用的方式是动态符号执行
动态符号执行的难点是无法无法覆盖所有代码，其主要原因包括
- 当程序代码规模增大时将导致符号执行的路径爆炸加剧，而输入依赖循环和递归等问题，导致路径爆炸更加严重，使得测试路径不深;
- 符号输入数据的增多使得求解超时和失败的情况增加，导致符号执行难以深入;
- 不完善的环境模型也将导致符号执行中断。

## 动态符号执行

动态符号执行是对传统符号执行的扩展，被称为现代符号执行技术。动态符号执行也被称为Concolic执行。
主要可以分为两种基本的方式。一种是 以具体执行为主导，程序以具体的输入驱动进行实际执行，而符号执行辅助具体 执行进行分析，从而增强运行时的分析能力。另一种是以符号执行为主导，程序 通过符号执行进行路径遍历，而具体执行主要帮助符号执行进行更高效、深入的 执行。比如当符号执行遇到求解超时或者失败的情况，符号执行引擎将无法继续 往下执行，此时则可以通过具体执行得到其中的一个具体解，从而帮助符号执行更深入的执行。

动态符号执行分为：Concolic Testing和Execution Generated Testing
```c
uint32 funcA( uint32 a ) {
    return 2*a; 
}
void testme(uint32 x, uint32 y, uint32 z){
    v = funcA(y);
    if(v = x){
        if(z > y + 10){
            abort();
        }
    }
}
int main(){
    uint32 x, y, z;
    testme(x, y, z);
    return 0;
}
```
- Concolic测试对每条指令进行一次具体执行和一次符号执行，每当执行到分支指令处，由具体执行得到的结果来选择下一条指令的执行方向，并通过符号执行来产生一个 新的测试用例，该测试用例理论上可以执行另一个分支。**具体的输入参数是否是随机选取的？如何通过符号执行产生测试用例？** 
    1. 输入值 x，y，z 需要给定一个初始值(由系统随机 产生，假定 x=1，y=1，z=1)。
    2. 在这个例子中，Concolic 测试需要执行 3 次执行来，遍历 testme 函数中的代码。
    3. 首先，在第一次执行时，当执行到第 10 行时，具体执行状态得到 v = 2，符号状态执行后记录 v = 2 ∗ y;
    4. 执行到第 11 行时，判断 v == x 不成立(此时 x=1，z=2)，并记录路径约束 (2y! = x)，然后执行 then 分支，至该路径结束。
    5. 通过对分支约束 (2y! = x) 进行求解并取反得到新的测试新的输入为(x=2，y=1，z=1)。此时可以在第11行进入if分支，当执行到第 12 行时，由 于 z > y + 10 不成立(此时 z=1,y=1)，则执行 then 分支，至该路径结束;
    6. 通过对分支约束 (z > y + 10) 进行求解取反，并产生新的输入(2，1，12)，此时可以在第 12 行进入 if 分支，检测到第 13 行的漏洞。至此，Concolic 测试完成了对 testme 函数的遍历。

- 执行生成测试则是使用同一形式表示具体执行状态和符号执行状态，**对每条指令只执行一次，具体执行或符号执行**。
    1. 进行执行生成测试(EGT 测试)时，x，y，z 可以通过用户指定是否为符号值， 假定 y=1，x 和 z 被指定为符号值。EGT 在每条指令执行前检测操作数是否为符号值，如果有则采用符号执行，否则采用具体执行；
    2. 当执行第 10 行时，由于 y 是具体值，则进行具体执行，得到 v = 2 ∗ y = 2；
    3. 当执行第 12 行时，由于 x 为符号值，则进行符号执行，根据分支条件 fork 产生 2 条路径(在 KLEE 中被称为 state)，并将路径约束 x == 2 和 x! = 2 分别加入相应的路径，记为 state1 和 state2;
    4. 当 state1 继续执行到第 12 行时，也产生 2 个 state，记为 state1 和 state3，路径约束分别为 (x == 2&&z > 11) 和 (x == 2&&z <= 11)。
    5. 从而路径 state1 可以执行到第 13 行， 检测到漏洞，并可以通过求解器产生触发漏洞的测试输入。
举例：

问题：
- **动态符号执行是在二进制的情况下进行执行检测还是源代码状态下进行检测？KLEE是在LLVM IR上进行执行；**
- **启发式选择执行路径，怎么理解?**
- **符号执行在遇到函数调用时，是如何处理的？将函数展开？**
- **libc中的系统调用，符号执行要如何处理**
- **如果函数参数是一个结构体的指针，该如何处理**

本文采用的方式：<br>
执行生成测试具有比 Concolic 测试的更强的漏洞检测能力，程序只要执行到包含漏洞的代码处， 即使没有真正的触发漏洞，也可以通过约束求解的方式来验证漏洞是否可能存在， 如果漏洞触发条件可满足，还能生成相应的测试输入。因此，在本文中主要研究执行生成测试方式的动态符号执行技术。

## 基于程序阶段特性的符号执行

### 背景和解决思路
现象：实际测试中，使用各种启发式的路径选择策略在对一个程序进行动态符号执行测试时，起初所覆盖的代码会迅速增长，但一段时间后，覆盖率的增速放缓，接下来就变得基本上不再增长了。<br>
原因：经过分析发现，导致这种现象的一个重要原因是由于程序阶段性的存在，符号执行在进入某个程序阶段后，受其影响而很难跨越并对后续的程序阶段。那些让符号执行容易陷入而难以头里的阶段成为陷入阶段。<br>
陷入阶段：包含一个或多个嵌套的循环处理结构，或者进行递归执行的代码;从该阶段进入到下一个阶段通常需要满足一些特定的条件。<br>
基本思路：1，识别这种阶段；2，分别对不同的阶段进行符号执行测试。所以实现了阶段的穿越。<br>


### 过程 
Conclic Execution
    - 收集SeedStates和BBVs
phase Analysis
    - 划分各个阶段（根据BBV的相似性来分析）
    - 根据 BBV 采集的时间和 seedState 产生的时间，将 seedState 对应到相应的 phase
Symbolic Execution
    - 对各个阶段进行符号执行测试；***这里的符号执行是动态符号执行吗*
### 问题：
- **系统是在什么级别上做符号执行的？二进制？LLVM？**
- BB是什么？基本块；BBV是什么？基本块向量
- 覆盖率与种子的选择相关
- 基本块指的是程序中的一段代码吗？
- 如果在Conclic Execution阶段就没有完全覆盖，那我这么得到各个阶段的信息呢？

### 阶段的自动划分
原则：将BBV之间，距离较短的合并为一个阶段；有 1/10 的时间在连续执行某一段 相似的代码时，我们认为这就是一个陷入阶段.<br>
问题：
- 是将BBV合并？还是将BB合并？
- 这里的距离是采集时间之间较短的意思吗

### 阶段的穿越
在符号执行测试中，只需要以相应的 seedState 为初始状态，展开符号执行测试即可。对 seedState 而言，已经包含了前面 concolic 执行的 路径信息，也就自然的完成了对前面阶段的穿越。

### 基于阶段的符号执行策略

### 基于多种子的代码覆盖提升
随机选择多个种子，进行符号执行，选择其中覆盖面较大的种子m。**覆盖率是怎么计算的？**
对 m 个种子进行 concolic 执行，收集 seedStates，并累加记录 seedState 中对于的分支指令的位置，当被执行的种子能覆盖到新的分支指令则保留为需要 选择的种子，否则丢弃该种子。从而得到一组最终的种子。

图3.3 pbSE 总体架构 32页

论文中的内容要把自己的目标定好。




